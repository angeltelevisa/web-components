"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDocsUrl = exports.getStringValue = exports.hasExpressions = exports.isTemplateLiteral = exports.isString = exports.isFunction = exports.isDescribe = exports.isTestCase = exports.argument2 = exports.argument = exports.method2 = exports.method = exports.expectNotToEqualCase = exports.expectToEqualCase = exports.expectNotToBeCase = exports.expectToBeCase = exports.expectNotRejectsCase = exports.expectRejectsCase = exports.expectNotResolvesCase = exports.expectResolvesCase = exports.expectNotCase = exports.expectCaseWithParent = exports.expectCase = void 0;

var _path = require("path");

var _package = require("../../package.json");

const REPO_URL = 'https://github.com/jest-community/eslint-plugin-jest';

const expectCase = node => node && node.callee && node.callee.name === 'expect';

exports.expectCase = expectCase;

const expectCaseWithParent = node => expectCase(node) && node.parent && node.parent.type === 'MemberExpression' && node.parent.parent;

exports.expectCaseWithParent = expectCaseWithParent;

const expectNotCase = node => expectCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node) === 'not';

exports.expectNotCase = expectNotCase;

const expectResolvesCase = node => expectCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node) === 'resolves';

exports.expectResolvesCase = expectResolvesCase;

const expectNotResolvesCase = node => expectNotCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node.parent) === 'resolves';

exports.expectNotResolvesCase = expectNotResolvesCase;

const expectRejectsCase = node => expectCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node) === 'rejects';

exports.expectRejectsCase = expectRejectsCase;

const expectNotRejectsCase = node => expectNotCase(node) && node.parent.parent.type === 'MemberExpression' && methodName(node.parent) === 'rejects';

exports.expectNotRejectsCase = expectNotRejectsCase;

const expectToBeCase = (node, arg) => !(expectNotCase(node) || expectResolvesCase(node) || expectRejectsCase(node)) && expectCase(node) && methodName(node) === 'toBe' && argument(node) && (argument(node).type === 'Literal' && argument(node).value === null && arg === null || argument(node).name === 'undefined' && arg === undefined);

exports.expectToBeCase = expectToBeCase;

const expectNotToBeCase = (node, arg) => expectNotCase(node) && methodName2(node) === 'toBe' && argument2(node) && (argument2(node).type === 'Literal' && argument2(node).value === null && arg === null || argument2(node).name === 'undefined' && arg === undefined);

exports.expectNotToBeCase = expectNotToBeCase;

const expectToEqualCase = (node, arg) => !(expectNotCase(node) || expectResolvesCase(node) || expectRejectsCase(node)) && expectCase(node) && methodName(node) === 'toEqual' && argument(node) && (argument(node).type === 'Literal' && argument(node).value === null && arg === null || argument(node).name === 'undefined' && arg === undefined);

exports.expectToEqualCase = expectToEqualCase;

const expectNotToEqualCase = (node, arg) => expectNotCase(node) && methodName2(node) === 'toEqual' && argument2(node) && (argument2(node).type === 'Literal' && argument2(node).value === null && arg === null || argument2(node).name === 'undefined' && arg === undefined);

exports.expectNotToEqualCase = expectNotToEqualCase;

const method = node => node.parent.property;

exports.method = method;

const method2 = node => node.parent.parent.property;

exports.method2 = method2;

const methodName = node => method(node).name;

const methodName2 = node => method2(node).name;

const argument = node => node.parent.parent.arguments && node.parent.parent.arguments[0];

exports.argument = argument;

const argument2 = node => node.parent.parent.parent.arguments && node.parent.parent.parent.arguments[0];

exports.argument2 = argument2;
const describeAliases = new Set(['describe', 'fdescribe', 'xdescribe']);
const testCaseNames = new Set(['fit', 'it', 'test', 'xit', 'xtest']);
const describeProperties = new Set(['each', 'only', 'skip']);
const testCaseProperties = new Set(['each', 'only', 'skip', 'todo']);

const isTestCase = node => node && node.type === 'CallExpression' && (node.callee.type === 'Identifier' && testCaseNames.has(node.callee.name) || node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && testCaseNames.has(node.callee.object.name) && node.callee.property.type === 'Identifier' && testCaseProperties.has(node.callee.property.name));

exports.isTestCase = isTestCase;

const isDescribe = node => node && node.type === 'CallExpression' && (node.callee.type === 'Identifier' && describeAliases.has(node.callee.name) || node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && describeAliases.has(node.callee.object.name) && node.callee.property.type === 'Identifier' && describeProperties.has(node.callee.property.name));

exports.isDescribe = isDescribe;

const isFunction = node => node && (node.type === 'FunctionExpression' || node.type === 'ArrowFunctionExpression');

exports.isFunction = isFunction;

const isString = node => node && (node.type === 'Literal' && typeof node.value === 'string' || isTemplateLiteral(node));

exports.isString = isString;

const isTemplateLiteral = node => node && node.type === 'TemplateLiteral';

exports.isTemplateLiteral = isTemplateLiteral;

const hasExpressions = node => node && node.expressions && node.expressions.length > 0;

exports.hasExpressions = hasExpressions;

const getStringValue = arg => isTemplateLiteral(arg) ? arg.quasis[0].value.raw : arg.value;
/**
 * Generates the URL to documentation for the given rule name. It uses the
 * package version to build the link to a tagged version of the
 * documentation file.
 *
 * @param {string} filename - Name of the eslint rule
 * @returns {string} URL to the documentation for the given rule
 */


exports.getStringValue = getStringValue;

const getDocsUrl = filename => {
  const ruleName = (0, _path.basename)(filename, '.js');
  return `${REPO_URL}/blob/v${_package.version}/docs/rules/${ruleName}.md`;
};

exports.getDocsUrl = getDocsUrl;